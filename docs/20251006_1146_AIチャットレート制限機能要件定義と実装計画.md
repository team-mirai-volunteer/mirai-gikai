# AIチャットレート制限機能 要件定義と実装計画

## 📋 要件定義

### 1. 背景と目的

#### 1.1 背景
現在、AIチャット機能は認証不要で誰でも利用可能な状態であり、以下の課題が存在する：
- API使用量の上限管理ができない
- コスト増加のリスク
- 悪意あるユーザーによる大量リクエストの可能性

#### 1.2 目的
匿名ユーザーでもAIチャット機能を利用できる状態を維持しつつ、適切な使用量制限を設けることでコストを管理し、サービスの持続可能性を確保する。

#### 1.3 設計思想
- **シンプル第一**: 初期実装では最小限の機能に絞る
- **段階的制限**: 完全なボット対策ではなく、通常ユーザーの利便性を損なわない範囲での制限
- **将来の拡張性**: 認証ユーザー機能への移行を見据えた設計

### 2. 機能要件

#### 2.1 匿名認証機能
- **Supabase Anonymous Auth の利用**
  - 初回訪問時に匿名ユーザーを自動作成
  - 匿名ユーザーIDをSupabaseセッションで管理
  - ブラウザのローカルストレージにセッション情報を保存

#### 2.2 トークン使用量管理
- **使用量トラッキング**
  - 各ユーザーのトークン使用量をデータベースで記録
  - 入力トークン + 出力トークンの合計を記録
  - チャットメッセージ送信ごとに使用量を更新

- **使用制限**
  - ユーザーごとの1日のトークン上限: 10,000トークン（定数管理）
  - 上限到達後はチャット機能を無効化
  - 毎日0時（JST）に使用量をリセット

- **定数管理**
  - `DAILY_TOKEN_LIMIT = 10000` として定数化
  - 将来的な調整が容易な設計

#### 2.3 制限到達時の動作
- **UIの変更**
  - AIチャットボタンを非表示にする
  - 制限到達メッセージを表示（オプション）
  - 将来的な正式登録への誘導メッセージ（オプション）

#### 2.4 セッション管理
- **Cookie/LocalStorage によるセッション永続化**
  - ブラウザを閉じても匿名ユーザーIDを保持
  - Supabaseの標準セッション管理機能を利用

- **キャッシュクリア時の動作**
  - 新しい匿名ユーザーとして扱う
  - 新たに1日10,000トークンの上限を付与
  - 過去の使用履歴とは紐づかない

#### 2.5 トークン使用量の日次管理
- **日次レコード管理**
  - 各ユーザーの `(user_id, date)` の組み合わせで日次レコードを作成
  - 今日の日付のレコードが存在しない場合、新規作成（`token_used = 0`）
  - 今日の日付のレコードが存在する場合、そのレコードの使用量をチェック
  - 過去の日付のレコードは保持（履歴として残る）

### 3. 非機能要件

#### 3.1 パフォーマンス
- トークン使用量チェック: 100ms以内
- 匿名ユーザー作成: 500ms以内
- データベース更新: 非同期処理（ユーザー体験に影響しない）

#### 3.2 セキュリティ
- **初期実装で対応しないこと**
  - IP ベースのレート制限
  - リクエスト頻度制限
  - 高度なボット検知

- **許容するリスク**
  - キャッシュクリアによる上限リセット
  - 単純なcurlリクエストによる悪用

#### 3.3 データ保持
- 匿名ユーザーのトークン使用履歴は永続的に保存
- 定期的なクリーンアップは実装しない（初期版）

### 4. 制約事項

#### 4.1 初期実装の制約
- リクエスト頻度のレート制限は実装しない
- IP制限は実装しない
- 複雑なボット対策は実装しない

#### 4.2 将来の拡張で対応する機能
- 認証ユーザーへの移行時のトークン引き継ぎ
- より安価なモデルへの自動切り替え
- IP ベースのレート制限
- ユーザー単位のリクエスト頻度制限

## 🏗️ 実装計画

### Phase 1: データベーススキーマ設計と作成

#### 1.1 新規テーブル: `user_token_usage`

```sql
CREATE TABLE user_token_usage (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    token_used INTEGER NOT NULL DEFAULT 0,
    token_limit INTEGER NOT NULL DEFAULT 10000,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT unique_user_date UNIQUE(user_id, date)
);

-- インデックス
CREATE INDEX idx_user_token_usage_user_id ON user_token_usage(user_id);
CREATE INDEX idx_user_token_usage_date ON user_token_usage(date);
CREATE INDEX idx_user_token_usage_user_date ON user_token_usage(user_id, date);

-- updated_at自動更新トリガー
CREATE TRIGGER update_user_token_usage_updated_at
    BEFORE UPDATE ON user_token_usage
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- コメント
COMMENT ON TABLE user_token_usage IS 'ユーザーごとの日次トークン使用量を管理するテーブル';
COMMENT ON COLUMN user_token_usage.date IS '使用日（日次レート制限のキー）';
COMMENT ON COLUMN user_token_usage.token_used IS 'その日に使用したトークン数';
```

#### 1.2 RLS ポリシー

```sql
-- RLS有効化
ALTER TABLE user_token_usage ENABLE ROW LEVEL SECURITY;

-- サービスロールのみアクセス可能（デフォルトで全禁止）
-- クライアントからの直接アクセスは許可しない
```

### Phase 2: 匿名認証機能の実装

#### 2.1 ディレクトリ構造

```
web/src/
├── features/
│   └── chat/
│       ├── actions/
│       │   ├── anonymous-auth.ts       # 匿名認証Server Action
│       │   ├── check-token-limit.ts    # トークン制限チェック
│       │   └── update-token-usage.ts   # トークン使用量更新
│       ├── hooks/
│       │   └── use-anonymous-auth.ts   # 匿名認証フック
│       ├── constants/
│       │   └── token-limits.ts         # トークン制限定数
│       ├── components/
│       │   ├── chat-button.tsx
│       │   ├── chat-window.tsx
│       │   └── ...
│       └── types/
│           └── index.ts
└── lib/
    └── supabase/
        └── client.ts                    # Supabaseクライアント
```

#### 2.2 定数定義

```typescript
// features/chat/constants/token-limits.ts
/**
 * 1日あたりのトークン使用上限
 * 匿名ユーザーが1日に使用できる最大トークン数
 */
export const DAILY_TOKEN_LIMIT = 10000;
```

#### 2.3 匿名認証実装

```typescript
// features/chat/actions/anonymous-auth.ts
"use server";

import { createClient } from "@/lib/supabase/server";
import { DAILY_TOKEN_LIMIT } from "../constants/token-limits";

export async function ensureAnonymousUser() {
  const supabase = await createClient();

  // 既存セッションチェック
  const { data: { session } } = await supabase.auth.getSession();

  if (session) {
    return { userId: session.user.id, isNew: false };
  }

  // 匿名ユーザー作成
  const { data, error } = await supabase.auth.signInAnonymously();

  if (error) {
    throw new Error(`Anonymous auth failed: ${error.message}`);
  }

  // user_token_usageレコード作成
  await initializeUserTokenUsage(data.user.id);

  return { userId: data.user.id, isNew: true };
}

async function initializeUserTokenUsage(userId: string) {
  const supabase = await createClient();

  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

  const { error } = await supabase
    .from("user_token_usage")
    .insert({
      user_id: userId,
      date: today,
      token_used: 0,
      token_limit: DAILY_TOKEN_LIMIT,
    });

  if (error) {
    console.error("Failed to initialize token usage:", error);
  }
}
```

- クライアント側からは認証しないので実装は必要ない

### Phase 3: トークン使用量管理機能

#### 3.1 トークン使用量チェック機能

```typescript
// features/chat/actions/check-token-limit.ts
"use server";

import { createClient } from "@/lib/supabase/server";

export async function checkTokenLimit(userId: string) {
  const supabase = await createClient();

  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

  // 今日の日付のレコードを取得
  const { data, error } = await supabase
    .from("user_token_usage")
    .select("token_used, token_limit")
    .eq("user_id", userId)
    .eq("date", today)
    .single();

  let tokenUsed = 0;
  let tokenLimit = DAILY_TOKEN_LIMIT;

  if (error) {
    // レコードが存在しない場合、新規作成
    if (error.code === 'PGRST116') {
      const { error: insertError } = await supabase
        .from("user_token_usage")
        .insert({
          user_id: userId,
          date: today,
          token_used: 0,
          token_limit: DAILY_TOKEN_LIMIT,
        });

      if (insertError) {
        console.error("Failed to create today's token usage:", insertError);
        return { canUse: false, remaining: 0, error: "Failed to create token usage" };
      }

      tokenUsed = 0;
      tokenLimit = DAILY_TOKEN_LIMIT;
    } else {
      return { canUse: false, remaining: 0, error: "Failed to fetch token usage" };
    }
  } else {
    tokenUsed = data.token_used;
    tokenLimit = data.token_limit;
  }

  const remaining = tokenLimit - tokenUsed;
  const canUse = remaining > 0;

  return { canUse, remaining, tokenUsed, tokenLimit };
}
```

#### 3.2 トークン使用量更新機能

```typescript
// features/chat/actions/update-token-usage.ts
"use server";

import { createClient } from "@/lib/supabase/server";

export async function updateTokenUsage(
  userId: string,
  inputTokens: number,
  outputTokens: number
) {
  const supabase = await createClient();

  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const totalTokens = inputTokens + outputTokens;

  // 今日の使用量を取得
  const { data: current } = await supabase
    .from("user_token_usage")
    .select("token_used")
    .eq("user_id", userId)
    .eq("date", today)
    .single();

  if (!current) {
    throw new Error("Today's token usage record not found");
  }

  // 使用量を更新
  const { error } = await supabase
    .from("user_token_usage")
    .update({
      token_used: current.token_used + totalTokens
    })
    .eq("user_id", userId)
    .eq("date", today);

  if (error) {
    console.error("Failed to update token usage:", error);
    throw error;
  }

  return { success: true, tokensAdded: totalTokens };
}
```

### Phase 4: チャットAPI統合

#### 4.1 既存チャットAPIの修正

```typescript
// app/api/chat/route.ts
import { streamText } from "ai";
import { createClient } from "@/lib/supabase/server";
import { checkTokenLimit } from "@/features/chat/actions/check-token-limit";
import { updateTokenUsage } from "@/features/chat/actions/update-token-usage";

export async function POST(req: Request) {
  const { messages, billContext } = await req.json();

  // 匿名ユーザーIDを取得
  const supabase = await createClient();
  const { data: { session } } = await supabase.auth.getSession();

  if (!session) {
    return new Response("Unauthorized", { status: 401 });
  }

  const userId = session.user.id;

  // トークン制限チェック
  const { canUse, remaining } = await checkTokenLimit(userId);

  if (!canUse) {
    return new Response(
      JSON.stringify({
        error: "Token limit reached",
        message: "トークンの上限に達しました。"
      }),
      {
        status: 429,
        headers: { "Content-Type": "application/json" }
      }
    );
  }

  const systemPrompt = `
    あなたは日本の議案について説明する専門的なアシスタントです。

    議案情報：
    - 名称: ${billContext.name}
    - 説明: ${billContext.description || ""}
    - 詳細: ${billContext.content || ""}
    - チームみらいのスタンス: ${billContext.miraiStance?.position || ""}
      理由: ${billContext.miraiStance?.reason || ""}

    ルール：
    1. この議案に関する質問にのみ回答する
    2. 分かりやすく簡潔に説明する
    3. 専門用語は必要に応じて解説する
    4. 議案と無関係の質問には「申し訳ございません。この議案に関する質問にお答えします」と返答する
  `;

  const result = streamText({
    model: "openai/gpt-4o-mini",
    system: systemPrompt,
    messages,
    apiKey: process.env.AI_GATEWAY_API_KEY,
    onFinish: async ({ usage }) => {
      // トークン使用量を記録（非同期）
      if (usage) {
        await updateTokenUsage(
          userId,
          usage.promptTokens,
          usage.completionTokens
        );
      }
    },
  });

  return result.toDataStreamResponse();
}
```

### Phase 5: UI実装

#### 5.1 チャットウィンドウの修正

```typescript
// features/chat/components/chat-window.tsx
"use client";

import { useChat } from "ai/react";
import { useEffect, useState } from "react";
import { useAnonymousAuth } from "@/features/chat/hooks/use-anonymous-auth";
import { checkTokenLimit } from "@/features/chat/actions/check-token-limit";

export function ChatWindow({ billContext, onClose }: ChatWindowProps) {
  const { userId, isLoading: authLoading } = useAnonymousAuth();
  const [tokenInfo, setTokenInfo] = useState<{
    canUse: boolean;
    remaining: number;
    tokenUsed: number;
    tokenLimit: number;
  } | null>(null);

  useEffect(() => {
    async function fetchTokenInfo() {
      if (!userId) return;

      const info = await checkTokenLimit(userId);
      setTokenInfo(info);
    }

    fetchTokenInfo();
  }, [userId]);

  const { messages, input, handleInputChange, handleSubmit, isLoading } =
    useChat({
      api: "/api/chat",
      body: {
        billContext,
      },
      initialMessages: [
        {
          id: "welcome",
          role: "assistant",
          content: `こんにちは！「${billContext.name}」について、ご質問はありませんか？

例えば、以下のような質問にお答えできます：
- この議案の目的は何ですか？
- どのような影響がありますか？
- みらいはなぜこのスタンスを取っているのですか？

お気軽にご質問ください。`,
        },
      ],
    });

  const isInputDisabled = !tokenInfo?.canUse || isLoading || authLoading;

  return (
    <div className="fixed inset-x-0 bottom-0 z-50 h-[70vh] bg-background shadow-xl md:bottom-4 md:right-4 md:left-auto md:h-[600px] md:w-[400px] md:rounded-lg flex flex-col">
      {/* ヘッダー */}
      <div className="flex items-center justify-between border-b p-4">
        <h2 className="text-lg font-semibold">議案について質問する</h2>
        <button
          onClick={onClose}
          className="rounded-full p-1 hover:bg-gray-100"
          aria-label="閉じる"
        >
          <X className="h-5 w-5" />
        </button>
      </div>

      {/* トークン残量表示 */}
      {tokenInfo && (
        <div className="border-b px-4 py-2 text-sm text-gray-600">
          残りトークン: {tokenInfo.remaining.toLocaleString()} / {tokenInfo.tokenLimit.toLocaleString()}
        </div>
      )}

      {/* 制限到達メッセージ */}
      {tokenInfo && !tokenInfo.canUse && (
        <div className="bg-yellow-50 border-b px-4 py-3 text-sm text-yellow-800">
          トークンの上限に達しました。チャット機能をご利用いただけません。
        </div>
      )}

      {/* メッセージエリア */}
      <Conversation className="flex-1 overflow-y-auto p-4">
        {messages.map((message) => (
          <Message
            key={message.id}
            role={message.role}
            className={`mb-4 ${
              message.role === "user" ? "justify-end" : "justify-start"
            }`}
          >
            {message.role === "assistant" ? (
              <StreamdownMessage content={message.content} />
            ) : (
              message.content
            )}
          </Message>
        ))}
        {isLoading && <Loader />}
      </Conversation>

      {/* 入力エリア */}
      <div className="border-t p-4">
        <PromptInput
          value={input}
          onChange={handleInputChange}
          onSubmit={handleSubmit}
          placeholder={
            isInputDisabled
              ? "チャットは利用できません"
              : "質問を入力してください..."
          }
          disabled={isInputDisabled}
        />
      </div>
    </div>
  );
}
```

#### 5.2 チャットボタンの修正

```typescript
// features/chat/components/chat-button.tsx
"use client";

import { MessageCircle } from "lucide-react";
import { useState, useEffect } from "react";
import { ChatWindow } from "./chat-window";
import { useAnonymousAuth } from "@/features/chat/hooks/use-anonymous-auth";
import { checkTokenLimit } from "../actions/check-token-limit";

export function ChatButton({ billContext }: ChatButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const { userId, isLoading } = useAnonymousAuth();
  const [canUseChat, setCanUseChat] = useState(true);

  useEffect(() => {
    async function checkLimit() {
      if (!userId) return;

      const { canUse } = await checkTokenLimit(userId);
      setCanUseChat(canUse);
    }

    checkLimit();
  }, [userId]);

  // 読み込み中またはトークン制限到達時は非表示
  if (isLoading || !canUseChat) {
    return null;
  }

  return (
    <>
      <button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-4 right-4 z-50 rounded-full bg-primary p-4 text-white shadow-lg hover:bg-primary/90 transition-colors md:bottom-8 md:right-8"
        aria-label="議案について質問する"
      >
        <MessageCircle className="h-6 w-6" />
      </button>

      {isOpen && (
        <ChatWindow
          billContext={billContext}
          onClose={() => setIsOpen(false)}
        />
      )}
    </>
  );
}
```

### Phase 6: テストとデバッグ

#### 6.1 単体テスト項目
- [ ] 匿名ユーザー作成が正常に動作する
- [ ] トークン使用量の記録が正確
- [ ] トークン制限チェックが正常に動作する
- [ ] 新しい日の自動レコード作成が動作する
- [ ] 制限到達時にチャットボタンが非表示になる
- [ ] DAILY_TOKEN_LIMIT定数が正しく適用される

#### 6.2 統合テスト項目
- [ ] 初回訪問時に匿名ユーザーが自動作成される
- [ ] チャット送信後にトークン使用量が更新される
- [ ] 10,000トークン到達後にチャットボタンが消える
- [ ] ブラウザリロード後もセッションが維持される
- [ ] キャッシュクリア後に新しい匿名ユーザーとして扱われる
- [ ] 新しい日になると、自動的に新しいレコードが作成される（`token_used = 0`）

#### 6.3 手動テスト項目
- [ ] 複数メッセージでトークンが累積される
- [ ] 残りトークン表示が正確
- [ ] 制限到達時にチャットボタンが非表示
- [ ] 翌日にチャットボタンが再表示される
- [ ] エラーハンドリングが適切

## 📊 実装スケジュール

### Phase 1: データベース準備（30分）
- スキーマ作成（`date`カラムで日次管理）
- RLSポリシー設定
- マイグレーション実行

### Phase 2: 匿名認証実装（1時間）
- 定数定義（DAILY_TOKEN_LIMIT）
- Server Action実装
- フック実装
- 基本的な動作確認

### Phase 3: トークン管理機能（1.5時間）
- チェック機能実装（日次レコード自動作成含む）
- 更新機能実装（日付ベース）
- エラーハンドリング

### Phase 4: API統合（1時間）
- チャットAPI修正
- トークン使用量記録
- 制限チェック統合

### Phase 5: UI実装（2時間）
- チャットウィンドウ修正
- チャットボタン修正（制限時非表示）
- 残量表示実装

### Phase 6: テスト（1時間）
- 単体テスト（リセット機能含む）
- 統合テスト
- 手動テスト

**合計見積もり時間**: 約7時間

## 🔐 セキュリティ考慮事項

### 現在の制約と受容するリスク
- **キャッシュクリアによる上限リセット**: 許容する
- **単純なスクリプトによる悪用**: 部分的に許容する
- **IP制限なし**: 初期実装では対応しない

### 将来の改善案
- Cloudflare Turnstileなどのボット対策
- IP単位のレート制限
- デバイスフィンガープリント
- より高度な異常検知

## 📈 成功指標

### 定量的指標
- 1日あたりのトークン使用量が想定範囲内（例: 1日100万トークン以内）
- 制限到達ユーザーの割合が10%以下
- 日次リセット成功率が99%以上
- API エラー率が1%以下

### 定性的指標
- 通常ユーザーの体験が損なわれない
- コスト管理が可能になる
- 明らかな悪用が防止できる

## 📚 参考資料

- [Supabase Anonymous Auth](https://supabase.com/docs/guides/auth/auth-anonymous)
- [Vercel AI SDK Usage Tracking](https://sdk.vercel.ai/docs/ai-sdk-core/usage)
- [Next.js Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
